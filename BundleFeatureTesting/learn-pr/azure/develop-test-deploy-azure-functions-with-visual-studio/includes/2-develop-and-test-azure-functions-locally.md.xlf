<?xml version="1.0"?><xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd"><file datatype="xml" original="2-develop-and-test-azure-functions-locally.md" source-language="en-US" target-language="en-US"><header><tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1931010" tool-company="Microsoft" /><xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2-develop-and-test-azure-functions-locally.1975af3872809e4b03d0f5039dfa3dd0778b477a.skl</xliffext:skl_file_name><xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version><xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6a4b0d7b0d4f437f66e63810faa2ca8d4edcf6df</xliffext:ms.openlocfilehash><xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/24/2019</xliffext:ms.lasthandoff><xliffext:ms.openlocfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">learn-pr\azure\develop-test-deploy-azure-functions-with-visual-studio\includes\2-develop-and-test-azure-functions-locally.md</xliffext:ms.openlocfilepath></header><body><group id="content" extype="content"><trans-unit id="101" translate="yes" xml:space="preserve">
          <source>You can write, debug, and deploy an Azure Function from within the Azure portal.</source>
        </trans-unit><trans-unit id="102" translate="yes" xml:space="preserve">
          <source>However, there are many scenarios when writing functions directly in the production, staging, or test environments might not be suitable.</source>
        </trans-unit><trans-unit id="103" translate="yes" xml:space="preserve">
          <source>For example, you could be writing automated unit tests for Azure Functions, or using on-demand deployment of Azure Functions to Azure Function Apps in Azure.</source>
        </trans-unit><trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Additionally, many developers prefer to use their favorite code editor and development tools rather than the environment provided by the Azure portal.</source>
        </trans-unit><trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Developing functions with Visual Studio enables you to manage Azure Functions code with code of other services inside the same projects.</source>
        </trans-unit><trans-unit id="106" translate="yes" xml:space="preserve">
          <source>In the luxury watch online website scenario, the developers are already familiar with Visual Studio.</source>
        </trans-unit><trans-unit id="107" translate="yes" xml:space="preserve">
          <source>So, you decide to use Visual Studio as the primary development environment for creating Azure Functions.</source>
        </trans-unit><trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Additionally, Visual Studio provides an excellent environment for testing your functions locally before deploying them to Azure.</source>
        </trans-unit><trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In this unit, you'll learn about the tools available with Visual Studio for building Azure Functions.</source>
        </trans-unit><trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You'll see how to install these tools, and use them to build and test an Azure Function locally.</source>
        </trans-unit><trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Install the Azure Functions tools extension for Visual Studio</source>
        </trans-unit><trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The Azure Functions tools are a Visual Studio extension that allows you to create, test, and deploy Azure Functions in your local development environment.</source>
        </trans-unit><trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This extension provides a template that you can use to quickly create a new Azure Functions app.</source>
        </trans-unit><trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You can then deploy an Azure Function directly to Azure from Visual Studio.</source>
        </trans-unit><trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You install the Azure Functions tools from the <bpt id="p1">*</bpt>Extensions and Updates<ept id="p1">*</ept> command in the <bpt id="p2">*</bpt>Tools<ept id="p2">*</ept> menu in Visual Studio.</source>
        </trans-unit><trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Search for <bpt id="p1">*</bpt>Azure Functions<ept id="p1">*</ept>, and then download and install the <bpt id="p2">*</bpt>Azure Functions and Web Job Tools<ept id="p2">*</ept> extension.</source>
        </trans-unit><trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Screenshot of the Extensions and Updates search page with the Azure Functions and Web Jobs Tools extension highlighted</source>
        </trans-unit><trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Create an Azure Functions app</source>
        </trans-unit><trans-unit id="119" translate="yes" xml:space="preserve">
          <source>When you've installed the extension, you create an Azure Functions app using the <bpt id="p1">*</bpt>Azure Functions<ept id="p1">*</ept> template.</source>
        </trans-unit><trans-unit id="120" translate="yes" xml:space="preserve">
          <source>You'll find this template in the <bpt id="p1">*</bpt>Cloud<ept id="p1">*</ept> folder under <bpt id="p2">*</bpt>Visual C#<ept id="p2">*</ept> in the <bpt id="p3">*</bpt>New Project<ept id="p3">*</ept> dialog.</source>
        </trans-unit><trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Screenshot of the New Project dialog box with the Azure Functions template highlighted</source>
        </trans-unit><trans-unit id="122" translate="yes" xml:space="preserve">
          <source>An Azure Function app hosts one or more Azure Functions.</source>
        </trans-unit><trans-unit id="123" translate="yes" xml:space="preserve">
          <source>It provides the environment and runtime for the functions.</source>
        </trans-unit><trans-unit id="124" translate="yes" xml:space="preserve">
          <source>An Azure Function is triggered by an event rather than being called directly from an application.</source>
        </trans-unit><trans-unit id="125" translate="yes" xml:space="preserve">
          <source>You specify the type of event that will trigger the functions in your function app.</source>
        </trans-unit><trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The events available include:</source>
        </trans-unit><trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Blob trigger<ept id="p1">**</ept>.</source>
        </trans-unit><trans-unit id="128" translate="yes" xml:space="preserve">
          <source>This type of function runs when a file is uploaded or modified in Azure Blob storage.</source>
        </trans-unit><trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Event Hub Trigger<ept id="p1">**</ept>.</source>
        </trans-unit><trans-unit id="130" translate="yes" xml:space="preserve">
          <source>An Event Hubs trigger runs the function when an Event Hub receives a message.</source>
        </trans-unit><trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Cosmos DB Trigger<ept id="p1">**</ept>.</source>
        </trans-unit><trans-unit id="132" translate="yes" xml:space="preserve">
          <source>This trigger runs when a document is added to, or modified in, a Cosmos DB database.</source>
        </trans-unit><trans-unit id="133" translate="yes" xml:space="preserve">
          <source>You can use this trigger to integrate Cosmos DB with other services.</source>
        </trans-unit><trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For example, if a document representing a customer's order is added to a database, you could use a trigger to send a copy of the order to a queue for processing.</source>
        </trans-unit><trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Http Trigger<ept id="p1">**</ept>.</source>
        </trans-unit><trans-unit id="136" translate="yes" xml:space="preserve">
          <source>An HTTP trigger runs the function when an HTTP request occurs in a web app.</source>
        </trans-unit><trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You can also use this trigger to respond to webhooks.</source>
        </trans-unit><trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A webhook is a callback that occurs when an item hosted by a website is modified.</source>
        </trans-unit><trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For example, you can create an Azure Function that is fired by a webhook from a GitHub repository when an item in the repository changes.</source>
        </trans-unit><trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Queue Trigger<ept id="p1">**</ept>.</source>
        </trans-unit><trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This trigger fires the function when a new item is added to an Azure Storage Queue.</source>
        </trans-unit><trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Service Bus Queue Trigger<ept id="p1">**</ept>.</source>
        </trans-unit><trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Use this trigger to run the function when a new item is added to an Azure Service Bus Queue.</source>
        </trans-unit><trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Service Bus Topic Trigger<ept id="p1">**</ept>.</source>
        </trans-unit><trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This trigger runs the function in response to a new message arriving on a Service Bus Topic.</source>
        </trans-unit><trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Timer Trigger<ept id="p1">**</ept>.</source>
        </trans-unit><trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Use this event to run the Azure Function at regular intervale, following a schedule that you define.</source>
        </trans-unit><trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Screenshot showing the Azure Function triggers available, with HTTP Trigger highlighted</source>
        </trans-unit><trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Azure currently provides two versions of the runtime environment required to run Azure Functions.</source>
        </trans-unit><trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Version 1 (v1) uses the .NET Framework 4.7, whereas version 2 (v2) runs using .NET Core 2.</source>
        </trans-unit><trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Using v2 triggers gives you the ability to develop and host the trigger in different environments.</source>
        </trans-unit><trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Version 1 triggers can only be created using Windows.</source>
        </trans-unit><trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Use v2 triggers where ever possible.</source>
        </trans-unit><trans-unit id="154" translate="yes" xml:space="preserve">
          <source>An Azure Function app stores management information, code, and logs in Azure Storage.</source>
        </trans-unit><trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Create a Storage Account to hold this data.</source>
        </trans-unit><trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The storage account must  support Azure Blob, Queue, Files, and Table storage; use a general Azure Storage account for this purpose.</source>
        </trans-unit><trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You specify which storage account to use for the function using the dialog box shown above.</source>
        </trans-unit><trans-unit id="158" translate="yes" xml:space="preserve">
          <source>An Azure Function can perform privileges or sensitive operations.</source>
        </trans-unit><trans-unit id="159" translate="yes" xml:space="preserve">
          <source>An Azure Function triggered by an HTTP request could be exposed publicly.</source>
        </trans-unit><trans-unit id="160" translate="yes" xml:space="preserve">
          <source>You might need to limit the ability to run this function to selected groups of users.</source>
        </trans-unit><trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You protect an Azure Function by specifying the access rights required to trigger the function.</source>
        </trans-unit><trans-unit id="162" translate="yes" xml:space="preserve">
          <source>An Azure Function triggered by an HTTP request supports three levels of access rights:</source>
        </trans-unit><trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Anonymous<ept id="p1">**</ept>.</source>
        </trans-unit><trans-unit id="164" translate="yes" xml:space="preserve">
          <source>No authentication is required, and any user can trigger the function.</source>
        </trans-unit><trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Function<ept id="p1">**</ept>.</source>
        </trans-unit><trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The HTTP request must provide a key that enables the Azure Function runtime to authorize the request.</source>
        </trans-unit><trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You create this key separately, and you can maintain it using the Azure portal.</source>
        </trans-unit><trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Admin<ept id="p1">**</ept>. This is similar to <bpt id="p2">**</bpt>Function<ept id="p2">**</ept> inasmuch as the user must specify a key with the HTTP request that triggers the function.</source>
        </trans-unit><trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The difference is that the key is an <bpt id="p1">*</bpt>admin<ept id="p1">*</ept> key.</source>
        </trans-unit><trans-unit id="170" translate="yes" xml:space="preserve">
          <source>This key can be used to access any function in the function app.</source>
        </trans-unit><trans-unit id="171" translate="yes" xml:space="preserve">
          <source>As with a function key, you create this key separately.</source>
        </trans-unit><trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If you're creating a function triggered by events other than HTTP requests, you're required to provide a connection string and other details necessary for the function app to access the resource triggering the event.</source>
        </trans-unit><trans-unit id="173" translate="yes" xml:space="preserve">
          <source>For example, if you're writing a function triggered by a Blob storage event, you must specify the connection string for the corresponding Blob storage account.</source>
        </trans-unit><trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Structure of an Azure Function</source>
        </trans-unit><trans-unit id="175" translate="yes" xml:space="preserve">
          <source>An Azure Function is implemented as a static class.</source>
        </trans-unit><trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The class provides a static, asynchronous method named <ph id="ph1">`Run`</ph>, which acts as the entry point for the function.</source>
        </trans-unit><trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The parameters passed to the <ph id="ph1">`Run`</ph> method provide the context for the trigger.</source>
        </trans-unit><trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In the case of an HTTP trigger, the function receives an <bpt id="p1">*</bpt>HttpRequest<ept id="p1">*</ept> object.</source>
        </trans-unit><trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This object contains the header and body of the request.</source>
        </trans-unit><trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You can access the data in the request using the same techniques available in any HTTP application.</source>
        </trans-unit><trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The attributes applied to this attribute specify the authorization requirements (<bpt id="p1">*</bpt>Anonymous<ept id="p1">*</ept> in this case), and the HTTP operations to which the Azure function responds (<bpt id="p2">*</bpt>GET<ept id="p2">*</ept> and <bpt id="p3">*</bpt>POST<ept id="p3">*</ept>).</source>
        </trans-unit><trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The example code generated by Visual Studio (shown below) examines the query string provided as part of the URL for the request and looks for a parameter called <bpt id="p1">*</bpt>name<ept id="p1">*</ept>.</source>
        </trans-unit><trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The code also uses a <bpt id="p1">*</bpt>StreamReader<ept id="p1">*</ept> to deserialize the body of the request and attempts to read the value of a property also called <bpt id="p2">*</bpt>name<ept id="p2">*</ept> from the request.</source>
        </trans-unit><trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">*</bpt>name<ept id="p1">*</ept> is found either in the query string or the body of the request, then it's returned in the response, otherwise the function generates an error response with the message <bpt id="p2">*</bpt>Please pass a name on the query string or in the request body<ept id="p2">*</ept>.</source>
        </trans-unit><trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The function returns a value containing any output data and results, wrapped in an <bpt id="p1">*</bpt>IAsynResult<ept id="p1">*</ept> object.</source>
        </trans-unit><trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The value is returned in the body of the HTTP response for the request.</source>
        </trans-unit><trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Different types of trigger receive different input parameters and return types.</source>
        </trans-unit><trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The next example shows the code generated for a Blob trigger.</source>
        </trans-unit><trans-unit id="189" translate="yes" xml:space="preserve">
          <source>In this example, the contents of the blob is made accessible through a <bpt id="p1">*</bpt>Stream<ept id="p1">*</ept> object, and the name of the blob is also provided.</source>
        </trans-unit><trans-unit id="190" translate="yes" xml:space="preserve">
          <source>No data is returned by the trigger; its purpose is to read and process the data in the named blob:</source>
        </trans-unit><trans-unit id="191" translate="yes" xml:space="preserve">
          <source>In all cases, an Azure Function is passed an <bpt id="p1">*</bpt>ILogger<ept id="p1">*</ept> parameter.</source>
        </trans-unit><trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The function can use this parameter to write log messages, which the function app will write to storage for later analysis.</source>
        </trans-unit><trans-unit id="193" translate="yes" xml:space="preserve">
          <source>An Azure Function also contains metadata that specify the type of the trigger and any other specific information and security requirements.</source>
        </trans-unit><trans-unit id="194" translate="yes" xml:space="preserve">
          <source>You can modify this metadata using the <bpt id="p1">*</bpt>HttpTrigger<ept id="p1">*</ept>, <bpt id="p2">*</bpt>BlobTrigger<ept id="p2">*</ept>, or other trigger attributes, as shown in the examples.</source>
        </trans-unit><trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>FunctionName<ept id="p1">*</ept> attribute that precedes the function is an identifier for the function used by the function app.</source>
        </trans-unit><trans-unit id="196" translate="yes" xml:space="preserve">
          <source>This name doesn't have to be the same as the name of the function, but it's good practice to keep them synchronized to avoid confusion.</source>
        </trans-unit><trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Test an Azure Functions app locally</source>
        </trans-unit><trans-unit id="198" translate="yes" xml:space="preserve">
          <source>You can use the Visual Debugger to build and test the Functions App locally.</source>
        </trans-unit><trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Press <bpt id="p1">*</bpt>F5<ept id="p1">*</ept>, or select <bpt id="p2">*</bpt>Start Debugging<ept id="p2">*</ept> on the <bpt id="p3">*</bpt>Debug<ept id="p3">*</ept> menu.</source>
        </trans-unit><trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The local version of the Function Runtime will start.</source>
        </trans-unit><trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Your functions will be available for testing.</source>
        </trans-unit><trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The example shows the runtime hosting the <bpt id="p1">*</bpt>Function1<ept id="p1">*</ept>.</source>
        </trans-unit><trans-unit id="203" translate="yes" xml:space="preserve">
          <source>This is the function triggered by an HTTP event.</source>
        </trans-unit><trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The URL indicates the endpoint to which the function is currently attached.</source>
        </trans-unit><trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Screenshot showing the Azure Function Runtime</source>
        </trans-unit><trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If you open a web browser and visit this URL, you'll trigger the function.</source>
        </trans-unit><trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The image below shows the response generated by an HTTP GET request that doesn't include a body.</source>
        </trans-unit><trans-unit id="208" translate="yes" xml:space="preserve">
          <source>You can see the message generated by the code that returns the <bpt id="p1">*</bpt>BadRequestObjectResult<ept id="p1">*</ept> object from the function:</source>
        </trans-unit><trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Screenshot showing the Azure Function Runtime</source>
        </trans-unit><trans-unit id="210" translate="yes" xml:space="preserve">
          <source>If you provide a query string that includes a <bpt id="p1">*</bpt>name<ept id="p1">*</ept> parameter, the value is read and processed by the function:</source>
        </trans-unit><trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Screenshot showing the Azure Function Runtime</source>
        </trans-unit><trans-unit id="212" translate="yes" xml:space="preserve">
          <source>While the code is running, you'll see trace messages appearing in the Function Runtime window.</source>
        </trans-unit><trans-unit id="213" translate="yes" xml:space="preserve">
          <source>You can use standard debugging features in Visual Studio if you need to set breakpoints and examine the flow of control in a function.</source>
        </trans-unit></group></body></file></xliff>