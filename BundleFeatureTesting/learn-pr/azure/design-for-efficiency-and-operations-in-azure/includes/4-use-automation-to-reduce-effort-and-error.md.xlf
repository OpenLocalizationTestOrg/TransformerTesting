<?xml version="1.0"?><xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd"><file datatype="xml" original="4-use-automation-to-reduce-effort-and-error.md" source-language="en-US" target-language="en-US"><header><tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1931010" tool-company="Microsoft" /><xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4-use-automation-to-reduce-effort-and-error.9175a1aea671ff57644b7a77d310f084378f986e.skl</xliffext:skl_file_name><xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version><xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7a0ee1b1018a9bc70590d0471e1b0a4236e2eafe</xliffext:ms.openlocfilehash><xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/13/2019</xliffext:ms.lasthandoff><xliffext:ms.openlocfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">learn-pr\azure\design-for-efficiency-and-operations-in-azure\includes\4-use-automation-to-reduce-effort-and-error.md</xliffext:ms.openlocfilepath></header><body><group id="content" extype="content"><trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Managing the infrastructure of any type of workload involves configuration tasks.</source>
        </trans-unit><trans-unit id="102" translate="yes" xml:space="preserve">
          <source>This configuration can be done manually, but manual steps can be labor-intensive, error prone, and inefficient.</source>
        </trans-unit><trans-unit id="103" translate="yes" xml:space="preserve">
          <source>What if you are assigned to lead a project that required the deployment of hundreds of systems on Azure?</source>
        </trans-unit><trans-unit id="104" translate="yes" xml:space="preserve">
          <source>How would you build and configure these resources?</source>
        </trans-unit><trans-unit id="105" translate="yes" xml:space="preserve">
          <source>How long would this take?</source>
        </trans-unit><trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Could you ensure that each system was configured properly, with no variance between them?</source>
        </trans-unit><trans-unit id="107" translate="yes" xml:space="preserve">
          <source>By using automation in your architecture design, you can work past these challenges.</source>
        </trans-unit><trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Let's take a look at some of the ways you can automate on Azure.</source>
        </trans-unit><trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Infrastructure as code</source>
        </trans-unit><trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Infrastructure as code is the management of infrastructure (networks, virtual machines, load balancers, and connection topology) in a descriptive model, using a versioning system similar to what is used for source code.</source>
        </trans-unit><trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Like the principle that the same source code generates the same binary, an IaC model generates the same environment every time it is applied.</source>
        </trans-unit><trans-unit id="112" translate="yes" xml:space="preserve">
          <source>IaC is a key DevOps practice and is often used in conjunction with continuous delivery.</source>
        </trans-unit><trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Infrastructure as code evolved to solve the problem of environment drift.</source>
        </trans-unit><trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Without IaC, teams must maintain the settings of individual deployment environments.</source>
        </trans-unit><trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Over time, each environment becomes a snowflake, that is, a unique configuration that cannot be reproduced automatically.</source>
        </trans-unit><trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Inconsistency among environments leads to issues during deployments.</source>
        </trans-unit><trans-unit id="117" translate="yes" xml:space="preserve">
          <source>With snowflakes, administration and maintenance of infrastructure involves manual processes which were hard to track and contributed to errors.</source>
        </trans-unit><trans-unit id="118" translate="yes" xml:space="preserve">
          <source>When automating the deployment of services and infrastructure, there are two different approaches you can take: imperative and declarative.</source>
        </trans-unit><trans-unit id="119" translate="yes" xml:space="preserve">
          <source>In an imperative approach, you explicitly state the commands that are executed to produce the outcome you are looking for.</source>
        </trans-unit><trans-unit id="120" translate="yes" xml:space="preserve">
          <source>With a declarative approach, you specify what you want the outcome to be instead of specifying how you want it done.</source>
        </trans-unit><trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Both approaches are valuable, so there's no wrong choice.</source>
        </trans-unit><trans-unit id="122" translate="yes" xml:space="preserve">
          <source>What do these different approaches look like on Azure, and how do you use them?</source>
        </trans-unit><trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Imperative automation</source>
        </trans-unit><trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Let's start with imperative automation.</source>
        </trans-unit><trans-unit id="125" translate="yes" xml:space="preserve">
          <source>With imperative automation, we're specifying <bpt id="p1">_</bpt>how<ept id="p1">_</ept> things are to be done.</source>
        </trans-unit><trans-unit id="126" translate="yes" xml:space="preserve">
          <source>This is typically done programmatically through a scripting language or SDK.</source>
        </trans-unit><trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For Azure resources, we could use the Azure CLI or Azure PowerShell.</source>
        </trans-unit><trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Let's take a look at an example that uses the Azure CLI to create a storage account.</source>
        </trans-unit><trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In this example, we're specifying how to create these resources.</source>
        </trans-unit><trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Execute a command to create a resource group.</source>
        </trans-unit><trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Execute another command to create a storage account.</source>
        </trans-unit><trans-unit id="132" translate="yes" xml:space="preserve">
          <source>We're explicitly telling Azure what commands to run to produce the output we need.</source>
        </trans-unit><trans-unit id="133" translate="yes" xml:space="preserve">
          <source>With this approach, we're able to fully automate our infrastructure.</source>
        </trans-unit><trans-unit id="134" translate="yes" xml:space="preserve">
          <source>We can provide areas for input and output, and can ensure that the same commands are executed every time.</source>
        </trans-unit><trans-unit id="135" translate="yes" xml:space="preserve">
          <source>By automating our resources, we've taken the manual steps out of the process, making resource administration operationally more efficient.</source>
        </trans-unit><trans-unit id="136" translate="yes" xml:space="preserve">
          <source>There are some downsides to this approach though.</source>
        </trans-unit><trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Scripts to create resources can quickly become complex as the architecture becomes more complex.</source>
        </trans-unit><trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Error handling and input validation may need to be added to ensure full execution.</source>
        </trans-unit><trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Commands may change, requiring ongoing maintenance of the scripts.</source>
        </trans-unit><trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Declarative automation</source>
        </trans-unit><trans-unit id="141" translate="yes" xml:space="preserve">
          <source>With declarative automation, we're specifying <bpt id="p1">_</bpt>what<ept id="p1">_</ept> we want our result to be, leaving the details of how it's done to the system we're using.</source>
        </trans-unit><trans-unit id="142" translate="yes" xml:space="preserve">
          <source>On Azure, declarative automation is done through the use of Azure Resource Manager templates.</source>
        </trans-unit><trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Resource Manager templates are JSON-structured files that specify what we want created.</source>
        </trans-unit><trans-unit id="144" translate="yes" xml:space="preserve">
          <source>In the example below, we're telling Azure to create a storage account with the names and properties that we specify.</source>
        </trans-unit><trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The actual steps that are executed to create this storage account are left to Azure.</source>
        </trans-unit><trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Templates have four sections: parameters, variables, resources, and outputs.</source>
        </trans-unit><trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Parameters handle input to be used within the template.</source>
        </trans-unit><trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Variables provide a way to store values for use throughout the template.</source>
        </trans-unit><trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Resources are the things that are being created, and outputs are a way to provide details to the user of what was created.</source>
        </trans-unit><trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Templates can be used to create and manipulate most services on Azure.</source>
        </trans-unit><trans-unit id="151" translate="yes" xml:space="preserve">
          <source>They can be stored in code repositories and source controlled, and shared across environments to ensure that the infrastructure being developed against matches what's actually in production.</source>
        </trans-unit><trans-unit id="152" translate="yes" xml:space="preserve">
          <source>They are a great way to automate deployments and help ensure consistency, eliminate deployment misconfigurations, and can increase operational speed.</source>
        </trans-unit><trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Automating your infrastructure deployment is a great first step, but when deploying virtual machines, there's still more work to do.</source>
        </trans-unit><trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Let's take a look at a couple of approaches to automating configuration post deployment.</source>
        </trans-unit><trans-unit id="155" translate="yes" xml:space="preserve">
          <source>VM customization: images vs. post-deployment configuration</source>
        </trans-unit><trans-unit id="156" translate="yes" xml:space="preserve">
          <source>For many virtual machine deployments, the job isn't done when the machine is running.</source>
        </trans-unit><trans-unit id="157" translate="yes" xml:space="preserve">
          <source>It's likely there's additional configuration that's needed before the VM can actually serve its intended purpose.</source>
        </trans-unit><trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Additional disks might need formatting, the VM might need to be joined to a domain, maybe an agent for a management software needs to be installed, and most likely the actual workload requires installation and configuration as well.</source>
        </trans-unit><trans-unit id="159" translate="yes" xml:space="preserve">
          <source>There are two common strategies applied for the configuration work considered to be part the configuration of the VM itself, both of which have advantages and disadvantages:</source>
        </trans-unit><trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Custom images</source>
        </trans-unit><trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Post-deployment scripting</source>
        </trans-unit><trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Custom images are generated by deploying a virtual machine and then configuring or installing software on that running instance.</source>
        </trans-unit><trans-unit id="163" translate="yes" xml:space="preserve">
          <source>When everything is configured correctly, the machine can be shut down, and an image is created from the VM.</source>
        </trans-unit><trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The image can then be used as a base for other new virtual machines.</source>
        </trans-unit><trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Working with custom images can speed up the overall time of your deployment as once the virtual machine is deployed and running, no additional configuration would be needed.</source>
        </trans-unit><trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If deployment speed is an important factor, custom images are definitely worth exploring.</source>
        </trans-unit><trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Post-deployment scripting typically leverages a basic base image, then relies on scripting or a configuration management platform to do configuration after the VM is deployed.</source>
        </trans-unit><trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The post-deployment scripting could be done by executing a script on the VM through the Azure Script Extension or by leveraging a more robust solution such as Azure Automation Desired State Configuration (DSC).</source>
        </trans-unit><trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Each approach has some considerations to keep in mind.</source>
        </trans-unit><trans-unit id="170" translate="yes" xml:space="preserve">
          <source>When using images, you'll need to ensure there's a process to handle image updates, security patches, and inventory management of the images themselves.</source>
        </trans-unit><trans-unit id="171" translate="yes" xml:space="preserve">
          <source>With post-deployment scripting, build times can be extended since the VM can't be added to live workloads until the build is complete.</source>
        </trans-unit><trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This may not be a significant issue for standalone systems, but when using services that autoscale (such as virtual machine scale sets), this extended build time can impact how quickly you can scale.</source>
        </trans-unit><trans-unit id="173" translate="yes" xml:space="preserve">
          <source>With both approaches, you'll want to ensure you address configuration drift; as new configuration is rolled out, you'll need to ensure that existing systems are updated accordingly.</source>
        </trans-unit><trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Automating resource deployment can be a massive benefit to your environment.</source>
        </trans-unit><trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The amount of time saved, and error reduced can move your operational capabilities to another level.</source>
        </trans-unit><trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Automation of operational tasks</source>
        </trans-unit><trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Once your solutions are up and running, there are ongoing operational activities that can also be automated.</source>
        </trans-unit><trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Automating these tasks with Azure Automation reduces manual workloads, enables configuration and update management of compute resources, centralizes shared resources such as schedules, credentials, and certificates, and provides a framework for running any type of Azure task.</source>
        </trans-unit><trans-unit id="179" translate="yes" xml:space="preserve">
          <source>For your Lamna Healthcare work, this might include:</source>
        </trans-unit><trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Periodically searching for orphaned disks.</source>
        </trans-unit><trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Installing the latest security patches on VMs.</source>
        </trans-unit><trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Searching for and shutting down virtual machines in off-hours.</source>
        </trans-unit><trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Running daily reports and producing a dashboard to report to senior management.</source>
        </trans-unit><trans-unit id="184" translate="yes" xml:space="preserve">
          <source>As a concrete example, suppose you want to run a virtual machine only during business hours.</source>
        </trans-unit><trans-unit id="185" translate="yes" xml:space="preserve">
          <source>You can write a script to start the VM in the morning and shut it down in the evening.</source>
        </trans-unit><trans-unit id="186" translate="yes" xml:space="preserve">
          <source>You can configure Azure Automation to run the script at set times.</source>
        </trans-unit><trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The following illustration shows the role of Azure Automation in this process.</source>
        </trans-unit><trans-unit id="188" translate="yes" xml:space="preserve">
          <source>An illustration showing the role of Azure Automation in managing a repetitive business process.</source>
        </trans-unit><trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Automating development environments</source>
        </trans-unit><trans-unit id="190" translate="yes" xml:space="preserve">
          <source>At the other end of the pipeline of your cloud infrastructure are the development machines used by developers to write the applications and services that are the core of your business.</source>
        </trans-unit><trans-unit id="191" translate="yes" xml:space="preserve">
          <source>You can use Azure DevTest Labs to stamp out VMs with all of the correct tools and repositories that they need.</source>
        </trans-unit><trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Developers working on multiple services can switch between development environments without having to provision a new machine themselves.</source>
        </trans-unit><trans-unit id="193" translate="yes" xml:space="preserve">
          <source>These development environments can be shut down when not in use and restarted when they are required again.</source>
        </trans-unit><trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Automation at Lamna Healthcare</source>
        </trans-unit><trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Let's take a look at how Lamna Healthcare has improved by using automation.</source>
        </trans-unit><trans-unit id="196" translate="yes" xml:space="preserve">
          <source>When you started your journey, infrastructure deployment and server builds were entirely manual.</source>
        </trans-unit><trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Engineers were deploying everything through the portal.</source>
        </trans-unit><trans-unit id="198" translate="yes" xml:space="preserve">
          <source>This was introducing variance and errors between test and production environments, and the differences were hindering their ability to detect problems before code hit production.</source>
        </trans-unit><trans-unit id="199" translate="yes" xml:space="preserve">
          <source>They now deploy all their infrastructure through Resource Manager templates.</source>
        </trans-unit><trans-unit id="200" translate="yes" xml:space="preserve">
          <source>These templates are checked into a GitHub repository, and a code review happens before they are released for deployment.</source>
        </trans-unit><trans-unit id="201" translate="yes" xml:space="preserve">
          <source>They're also able to build the same infrastructure between dev, test, and production, ensuring they have validated their configuration across all environments.</source>
        </trans-unit><trans-unit id="202" translate="yes" xml:space="preserve">
          <source>For most services using virtual machines, they have a standard base image and use DSC to configure the systems post deployment.</source>
        </trans-unit><trans-unit id="203" translate="yes" xml:space="preserve">
          <source>For web farms where they need the scalability of virtual machine scale sets, they have a fully automated process to check in code and build a new image with all required configuration built in before making it available in their scale sets.</source>
        </trans-unit><trans-unit id="204" translate="yes" xml:space="preserve">
          <source>They have an Automation job to shut down identified virtual machines in off-hours to reduce costs and have automated their VM patching as well.</source>
        </trans-unit><trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Developers now have a self-service environment in DevTest Labs where they can develop against the latest images and configuration, ensuring that what they develop against matches the configuration in production.</source>
        </trans-unit><trans-unit id="206" translate="yes" xml:space="preserve">
          <source>All of this took some up-front effort, but the benefits have paid off in the long run.</source>
        </trans-unit><trans-unit id="207" translate="yes" xml:space="preserve">
          <source>They've dramatically reduced error and the effort required by their operations teams to maintain their environments.</source>
        </trans-unit><trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Developers love that they can easily go provision resources to develop against, eliminating the back and forth to get environments created.</source>
        </trans-unit><trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Summary</source>
        </trans-unit><trans-unit id="210" translate="yes" xml:space="preserve">
          <source>We've taken a look at a number of ways to bring automation capabilities into your architecture.</source>
        </trans-unit><trans-unit id="211" translate="yes" xml:space="preserve">
          <source>From deploying infrastructure as code, to improving developer productivity with lab environments, there's a ton of benefit from taking time to automate your environment.</source>
        </trans-unit><trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Reducing error, reducing variance, and saving operational costs can be a significant benefit to your organization and help take your cloud environment to the next level.</source>
        </trans-unit></group></body></file></xliff>