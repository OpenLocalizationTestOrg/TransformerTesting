<?xml version="1.0"?><xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd"><file datatype="xml" original="2-identify-scenarios.md" source-language="en-US" target-language="en-US"><header><tool tool-id="mdxliff" tool-name="mdxliff"  tool-company="Microsoft" /><xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2-identify-scenarios.3eaa2c.5005880a7280edec431406b143d1830c7f7452f4.skl</xliffext:skl_file_name><xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version><xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5005880a7280edec431406b143d1830c7f7452f4</xliffext:ms.openlocfilehash><xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ba7e452ac39d7f09a5646044b44de0e1cdc54982</xliffext:ms.sourcegitcommit><xliffext:ms.openlocfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">learn-pr\azure\app-service-autoscale-rules\includes\2-identify-scenarios.md</xliffext:ms.openlocfilepath></header><body><group id="content" extype="content"><trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Autoscaling can be triggered according to a schedule, or by assessing whether the system is running short on resources.</source>
        </trans-unit><trans-unit id="102" translate="yes" xml:space="preserve">
          <source>For example, autoscaling could be triggered if CPU utilization grows, memory occupancy increases, the number of incoming requests to a service appears to be surging, or some combination of factors.</source>
        </trans-unit><trans-unit id="103" translate="yes" xml:space="preserve">
          <source>In the hotel reservation system, autoscaling is useful for handling short-term spikes in the number of booking requests.</source>
        </trans-unit><trans-unit id="104" translate="yes" xml:space="preserve">
          <source>You can also use scheduled autoscaling to provide additional resources at peak times.</source>
        </trans-unit><trans-unit id="105" translate="yes" xml:space="preserve">
          <source>What is autoscaling?</source>
        </trans-unit><trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Autoscaling is a cloud system or process that adjusts avalaible resources based on the current demand.</source>
        </trans-unit><trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Autoscaling performs scaling <bpt id="p1">*</bpt>in and out<ept id="p1">*</ept>, as opposed to scaling <bpt id="p2">*</bpt>up and down<ept id="p2">*</ept>.</source>
        </trans-unit><trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Azure App Service Autoscaling</source>
        </trans-unit><trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Autoscaling in Azure App Service monitors the resource metrics of a web app as it runs.</source>
        </trans-unit><trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It detects situations where additional resources are required to handle an increasing workload, and ensures those resources are available before the system becomes overloaded.</source>
        </trans-unit><trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Autoscaling responds to changes in the environment by adding or removing web servers and balancing the load between them.</source>
        </trans-unit><trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Autoscaling doesn't have any effect on the CPU power, memory, or storage capacity of the web servers powering the app, it only changes the number of web servers.</source>
        </trans-unit><trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Autoscaling rules</source>
        </trans-unit><trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Autoscaling makes its decisions based on rules that you define.</source>
        </trans-unit><trans-unit id="115" translate="yes" xml:space="preserve">
          <source>A rule specifies the threshold for a metric, and triggers an autoscale event when this threshold is crossed.</source>
        </trans-unit><trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Autoscaling can also deallocate resources when the workload has diminished.</source>
        </trans-unit><trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Define your autoscaling rules carefully.</source>
        </trans-unit><trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For example, a Denial of Service attack will likely result in a large-scale influx of incoming traffic.</source>
        </trans-unit><trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Trying to handle a surge in requests caused by a DoS attack would be fruitless and expensive.</source>
        </trans-unit><trans-unit id="120" translate="yes" xml:space="preserve">
          <source>These requests aren't genuine, and should be discarded rather than processed.</source>
        </trans-unit><trans-unit id="121" translate="yes" xml:space="preserve">
          <source>A better solution is to implement detection and filtering of requests that occur during such an attack before they reach your service.</source>
        </trans-unit><trans-unit id="122" translate="yes" xml:space="preserve">
          <source>When should you consider autoscaling?</source>
        </trans-unit><trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Autoscaling provides elasticity for your services.</source>
        </trans-unit><trans-unit id="124" translate="yes" xml:space="preserve">
          <source>It's a suitable solution when hosting any application when you can't easily predict the workload in advance, or when the workload is likely to vary by date or time.</source>
        </trans-unit><trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For example, you might expect increased/reduced activity for a business app during holidays.</source>
        </trans-unit><trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Autoscaling improves availability and fault tolerance.</source>
        </trans-unit><trans-unit id="127" translate="yes" xml:space="preserve">
          <source>It can help ensure that client requests to a service won't be denied because an instance is either not able to acknowledge the request in a timely manner, or because an overloaded instance has crashed.</source>
        </trans-unit><trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Autoscaling works by adding or removing web servers.</source>
        </trans-unit><trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If your web apps perform  resource-intensive processing as part of each request, then autoscaling might not be an effective approach.</source>
        </trans-unit><trans-unit id="130" translate="yes" xml:space="preserve">
          <source>In these situations, manually scaling up may be necessary.</source>
        </trans-unit><trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For example, if a request sent to a web app involves performing complex processing over a large dataset, depending on the instance size, this single request could exhaust the processing and memory capacity of the instance.</source>
        </trans-unit><trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Autoscaling isn't the best approach to handling long-term growth.</source>
        </trans-unit><trans-unit id="133" translate="yes" xml:space="preserve">
          <source>You might have a web app that starts with a small number of users, but increases in popularity over time.</source>
        </trans-unit><trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Autoscaling has an overhead associated with monitoring resources and determining whether to trigger a scaling event.</source>
        </trans-unit><trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In this scenario, if you can anticipate the rate of growth, manually scaling the system over time may be a more cost effective approach.</source>
        </trans-unit><trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The number of instances of a service is also a factor.</source>
        </trans-unit><trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You might expect to run only a few instances of a service most of the time.</source>
        </trans-unit><trans-unit id="138" translate="yes" xml:space="preserve">
          <source>However, in this situation, your service will always be susceptible to downtime or lack of availability whether autoscaling is enabled or not.</source>
        </trans-unit><trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The fewer the number of instances initially, the less capacity you have to handle an increasing workload while autoscaling spins up additional instances.</source>
        </trans-unit></group></body></file></xliff>